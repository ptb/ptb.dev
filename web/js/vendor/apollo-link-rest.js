/*! @copyright Apollo GraphQL | @license MIT | @link apollographql.com | @version 0.7.0 *//* eslint-disable */import{ApolloLink as e,Observable as t}from"./apollo-link.js";import{checkDocument as r,removeDirectivesFromDocument as n,hasDirectives as s,addTypenameToDocument as o,getMainDefinition as i,getFragmentDefinitions as a,createFragmentMap as l,isInlineFragment as c,isField as u,resultKeyNameFromField as p}from"./apollo-utilities.js";import{default as d}from"./graphql-anywhere.js";import{stringify as h}from"./qs.js";const f={test:e=>"rest"===e.name.value,remove:!0},y=new Map;const m=(e,t,r)=>{if(Array.isArray(e)){const n=(e=>{const t=e.replace(/\s/g,"");return t.replace(/\[(.*)\]/,(e,r,n,s)=>((null!=r&&r.length)>0?r:null)||t)})(t);return e.map(e=>m(e,n,r))}return null==e||"number"==typeof e||"boolean"==typeof e||"string"==typeof e?e:r(e,t,r)},w=e=>e.directives&&e.directives.length?e.directives.find(e=>"rest"===e.name.value):null;function g(e,t,r,n,s){return null==s||null==t||"number"==typeof t||"boolean"==typeof t||"string"==typeof t?t:(s.selections.forEach(s=>{if(c(s))g(e,t,r,n,s.selectionSet);else if("FragmentSpread"===s.kind){const o=n[s.name.value];g(e,t,r,n,o.selectionSet)}else{if(!u(s))return(e=>{throw new Error("Unhandled Node Type in SelectionSetNode.selections")})();p(s)===e&&null!=w(s)?function e(t,r,n,s){if(null==t||"number"==typeof t||"boolean"==typeof t||"string"==typeof t)return;if(Array.isArray(t))return void t.forEach(t=>e(t,r,n,s));s.selections.forEach(s=>{if(c(s))e(t,r,n,s.selectionSet);else if("FragmentSpread"===s.kind){const o=n[s.name.value];e(t,r,n,o.selectionSet)}else{if(!u(s))return(e=>{throw new Error("Unhandled Node Type in SelectionSetNode.selections")})();{const o=t[s.name.value];"__typename"===s.name.value||(void 0===o?t[s.name.value]=null:null!=o&&"object"==typeof o&&null!=s.selectionSet&&e(o,r,n,s.selectionSet))}}})}(t,r,n,s.selectionSet):g(e,t,r,n,s.selectionSet)}}),t)}class b{static replacerForPath(e){if(e in b.cache)return b.cache[e];const t=e.indexOf("?"),r=e.split(b.argReplacement),n=[];let s=!1;r.reduce((r,o)=>{if(""===o||"{}"===o)return r+o.length;const i=r+o.length;if("{"===o[0]&&"}"===o[o.length-1]){const t=o.slice(1,o.length-1).split(".");n.push((r,n)=>{try{const s=function e(t,r){if(0===r.length)return t;const n=[...r];const s=n.shift();return e(t[s],n)}(r,t);return n&&"object"==typeof s&&null!=s?h(s):String(s)}catch(r){const n=[e,t.join(".")].join("|");return n in b.warnTable||(console.warn("Warning: RestLink caught an error while unpacking",n,"This tends to happen if you forgot to pass a parameter needed for creating an @rest(path, or if RestLink was configured to deeply unpack a path parameter that wasn't provided. This message will only log once per detected instance. Trouble-shooting hint: check @rest(path: and the variables provided to this query."),b.warnTable[n]=!0),""}})}else n.push(o),!s&&i>=t&&(s=!0,n.push(!0));return i},0);return b.cache[e]=(e=>{let t=!1;return n.reduce((r,n)=>"string"==typeof n?r+n:"boolean"==typeof n?(t=!0,r):r+n(e,t),"")})}}b.cache={},b.warnTable={},b.argReplacement=/({[._a-zA-Z0-9]*})/;const v=["__typename"],T=(e,t,r=[])=>{let n=null;return n=2!=t.length?(e,r)=>t(e):t,null==e||"object"!=typeof e?e:e instanceof FileList||e instanceof File?e:Array.isArray(e)?e.map((e,t)=>T(e,n,[...r,String(t)])):Object.keys(e).reduce((t,s)=>{let o=e[s];if(-1!==v.indexOf(s))return t[s]=o,t;const i=[...r,s];return t[n(s,i)]=T(o,n,i),t},{})},E=e=>e,z=e=>e instanceof Headers?e:new Headers(e||{}),A=(...e)=>e.reduce((e,t)=>t?(t.forEach||(t=z(t)),t.forEach((t,r)=>{e.append(r,t)}),e):e,new Headers),S=e=>(t,r)=>((e,t,r)=>{const n=new Headers;return e.forEach((e,r)=>{-1===t.indexOf(r)&&n.append(r,e)}),A(n,r||new Headers)})(t,e,r),x=["GET","POST","PUT","PATCH","DELETE"],k=(e,t)=>null==e||"object"!=typeof e?e:Array.isArray(e)?e.map(e=>k(e,t)):(e.__typename=t,e),N=async(e,t,r,n,s)=>{const{directives:o,isLeaf:i,resultKey:a}=s,{exportVariables:c}=n,u=(t||{})[a],p=(t||{})[e];t&&o&&o.export&&(c[o.export.as]=p);const d=o&&o.type;if(!i&&d){if(o.rest)throw new Error("Invalid use of @type(name: ...) directive on a call that also has @rest(...)");return k(p,o.type.name)}if(!o||!o.rest)return u||p;const{credentials:h,endpoints:f,headers:y,customFetch:w,operationType:v,typePatcher:z,mainDefinition:A,fragmentDefinitions:S,fieldNameNormalizer:N,fieldNameDenormalizer:R,serializers:j,responseTransformer:q}=n,L=l(S);let{path:D,endpoint:_,pathBuilder:F}=o.rest;const C=((e,t)=>{const r=e[t||P]||e[P];return"string"==typeof r?{uri:r}:{responseTransformer:null,...r}})(f,_);if(null==D&&null==F)throw new Error('One of ("path" | "pathBuilder") must be set in the @rest() directive. This request had neither, please add one');F||(D.includes(":")?(console.warn("Deprecated: '@rest(path:' contains a ':' colon, this format will be removed in future versions"),F=(({args:e,exportVariables:t})=>{const r={...e,...t},n=Object.keys(r).reduce((e,t)=>((e,t,r)=>void 0===r||void 0===t?e:e.replace(`:${t}`,r))(e,t,r[t]),D);if(n.includes(":"))throw new Error('Missing parameters to run query, specify it in the query params or use an export directive. (If you need to use ":" inside a variable string make sure to encode the variables properly using `encodeURIComponent`. Alternatively see documentation about using pathBuilder.)');return n})):F=b.replacerForPath(D));const $={args:r,exportVariables:c,context:n,"@rest":o.rest,replacer:F},H=F($);let{method:U,type:B,bodyBuilder:G,bodyKey:V,fieldNameDenormalizer:I,bodySerializer:M}=o.rest;U||(U="GET"),V||(V="input");let K=void 0,J=void 0;if(-1===["GET","DELETE"].indexOf(U)){if(!G){const e=$.exportVariables[V]||$.args&&$.args[V];if(!e)throw new Error(`[GraphQL ${U} ${v} using a REST call without a body]. No \`${V}\` was detected. Pass bodyKey, or bodyBuilder to the @rest() directive to resolve this.`);G=(t=>e)}let e;if(K=T(G($),I||R||E),"string"==typeof M){if(!j.hasOwnProperty(M))throw new Error('"bodySerializer" must correspond to configured serializer. '+`Please make sure to specify a serializer called ${M} in the "bodySerializers" property of the RestLink.`);e=j[M](K,y)}else e=M?M(K,y):j[O](K,y);K=e.body,J=new Headers(e.headers)}((e,t)=>{switch(t){case"query":if(-1!==x.indexOf(e.toUpperCase()))return;throw new Error(`A "query" operation can only support "GET" requests but got "${e}".`);case"mutation":if(-1!==x.indexOf(e.toUpperCase()))return;throw new Error('"mutation" operations do not support that HTTP-verb');case"subscription":throw new Error('A "subscription" operation is not supported yet.');default:;}})(U,v||"query");const Q={method:U,headers:J||y,body:K,...h?{credentials:h}:{}},W=`${C.uri}${H}`,Z=await(w||fetch)(W,Q);let X;if(n.responses.push(Z),Z.ok)X=204===Z.status||"0"===Z.headers.get("Content-Length")?{}:Z;else if(404===Z.status)X=null;else{let e;try{e=await Z.clone().json()}catch(t){e=await Z.clone().text()}((e,t,r)=>{const n=new Error(r);throw n.response=e,n.statusCode=e.status,n.result=t,n})(Z,e,`Response not successful: Received status code ${Z.status}`)}const Y=C.responseTransformer||q;if(Y)try{X=await Y(X,B)}catch(e){throw console.warn("An error occurred in a responseTransformer:"),e}else X&&X.json&&(X=await X.json());return null!==N&&(X=T(X,N)),X=g(a,X,A,L,A.selectionSet),m(X,B,z)},P="",O="",R=(e,t)=>(t.has("content-type")||t.append("Content-Type","application/json"),{body:JSON.stringify(e),headers:t});class j extends e{constructor({uri:e,endpoints:t,headers:r,fieldNameNormalizer:n,fieldNameDenormalizer:s,typePatcher:o,customFetch:i,credentials:a,bodySerializers:l,defaultSerializer:c,responseTransformer:u}){super();const p={};if(p[P]=e||"",this.endpoints=Object.assign({},t||p),null==e&&null==t)throw new Error("A RestLink must be initialized with either 1 uri, or a map of keyed-endpoints");if(null!=e){const r=(t||{})[P];if(null!=r&&r!=e)throw new Error("RestLink was configured with a default uri that doesn't match what's passed in to the endpoints map.");this.endpoints[P]=e}if(null==this.endpoints[P]&&console.warn("RestLink configured without a default URI. All @rest(â€¦) directives must provide an endpoint key!"),null==o)this.typePatcher=((e,t,r)=>({__typename:t,...e}));else{if(Array.isArray(o)||"object"!=typeof o||!Object.keys(o).map(e=>o[e]).reduce((e,t)=>e&&"function"==typeof t,!0))throw new Error("RestLink was configured with a typePatcher of invalid type!");{const e=o;this.typePatcher=((t,r,n)=>{const s=t.__typename||r;if(Array.isArray(t))return t.map(e=>n(e,s,n));const o=e[s]||(e=>e);return{__typename:s,...o(t,s,n)}})}}l&&l.hasOwnProperty(O)&&console.warn("RestLink was configured to override the default serializer! This may result in unexpected behavior"),this.responseTransformer=u||null,this.fieldNameNormalizer=n||null,this.fieldNameDenormalizer=s||null,this.headers=z(r),this.credentials=a||null,this.customFetch=i,this.serializers={[O]:c||R,...l||{}}}request(e,l){const{query:c,variables:u,getContext:p,setContext:h}=e,m=p();if(!s(["rest"],c))return l(e);const w=function(e){const t=y.get(e);if(t)return t;r(e);const s=n([f],e);return y.set(e,s),s}(c);let g=m.headersMergePolicy;null==g&&Array.isArray(m.headersToOverride)?g=S(m.headersToOverride):null==g&&(g=A);const b=g(this.headers,m.headers);b.has("Accept")||b.append("Accept","application/json");const v=m.credentials||this.credentials,T=o(c),E=i(c),z=a(c),x=(E||{}).operation||"query",k={headers:b,endpoints:this.endpoints,exportVariables:{},credentials:v,customFetch:this.customFetch,operationType:x,fieldNameNormalizer:this.fieldNameNormalizer,fieldNameDenormalizer:this.fieldNameDenormalizer,mainDefinition:E,fragmentDefinitions:z,typePatcher:this.typePatcher,serializers:this.serializers,responses:[],responseTransformer:this.responseTransformer},P={};let O;return w&&l?(e.query=w,O=l(e)):O=t.of({data:{}}),O.flatMap(({data:e,errors:r})=>new t(t=>{d(N,T,e,k,u,P).then(e=>{h({restResponses:(m.restResponses||[]).concat(k.responses)}),t.next({data:e,errors:r}),t.complete()}).catch(e=>{"AbortError"!==e.name&&(e.result&&e.result.errors&&t.next(e.result),t.error(e))})}))}}export{j as RestLink,b as PathBuilder};